<div class="bg-gray-50 min-h-screen" data-controller="infinite-scroll">
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
    <div class="flex flex-col lg:flex-row gap-8">
      <!-- Main content (2/3) -->
      <div class="lg:w-2/3">
        <div id="posts-container" class="space-y-8">
          <%= render 'post', post: @post %>
        </div>

        <!-- Loading indicators -->
        <div class="hidden" data-infinite-scroll-target="loadingNext">
          <div class="flex justify-center items-center py-8">
            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600"></div>
          </div>
        </div>
        <div class="hidden" data-infinite-scroll-target="loadingPrevious">
          <div class="flex justify-center items-center py-8">
            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600"></div>
          </div>
        </div>
      </div>

      <!-- Sidebar with next posts (1/3) -->
      <div class="lg:w-1/3">
        <div class="bg-white shadow sm:rounded-lg overflow-hidden sticky top-8">
          <div class="px-4 py-5 sm:p-6">
            <h2 class="text-lg font-medium text-gray-900 mb-4">More Posts</h2>
            <div id="next-posts-container">
              <%= render 'next_posts', next_posts: @next_posts %>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<%# JavaScript for infinite scroll %>
<%= javascript_tag do %>
  document.addEventListener('turbo:load', function() {
    let loading = false;
    let lastScrollY = window.scrollY;
    const container = document.querySelector('[data-controller="infinite-scroll"]');
    const postsContainer = document.getElementById('posts-container');
    const nextPostsContainer = document.getElementById('next-posts-container');
    const loadingNext = container.querySelector('[data-infinite-scroll-target="loadingNext"]');
    const loadingPrevious = container.querySelector('[data-infinite-scroll-target="loadingPrevious"]');
    let currentPostId = <%= @post.id %>;
    let hasNext = <%= @next_post.present? %>;
    let hasPrevious = <%= @previous_post.present? %>;

    // Function to ensure posts take at least full viewport height
    function ensureMinHeight() {
      const posts = postsContainer.querySelectorAll('article');
      posts.forEach(post => {
        const viewportHeight = window.innerHeight;
        const postHeight = post.offsetHeight;
        if (postHeight < viewportHeight) {
          post.style.minHeight = `${viewportHeight}px`;
        }
      });
    }

    // Call on initial load
    ensureMinHeight();

    // Call on window resize
    window.addEventListener('resize', ensureMinHeight);

    function updateUrl(postId) {
      history.pushState({}, '', `/posts/${postId}`);
    }

    function loadPost(postId, direction = 'next') {
      if (loading) return;
      
      loading = true;
      const loadingIndicator = direction === 'next' ? loadingNext : loadingPrevious;
      loadingIndicator.classList.remove('hidden');

      fetch(`/posts/${postId}.json`)
        .then(response => response.json())
        .then(data => {
          // Update the current post ID and navigation state
          currentPostId = data.post_id;
          hasNext = data.has_next;
          hasPrevious = data.has_previous;

          // Update the URL to reflect the current post
          updateUrl(currentPostId);

          // Update the post content
          if (direction === 'next') {
            postsContainer.insertAdjacentHTML('beforeend', data.post);
          } else {
            postsContainer.insertAdjacentHTML('afterbegin', data.post);
            // Adjust scroll position to maintain the same view
            window.scrollBy(0, postsContainer.firstElementChild.offsetHeight);
          }

          // Ensure new post meets minimum height
          ensureMinHeight();

          // Update the next posts sidebar
          nextPostsContainer.innerHTML = data.next_posts;

          // Clean up old posts (keep only 3 in the DOM)
          const posts = postsContainer.children;
          if (posts.length > 3) {
            if (direction === 'next') {
              posts[0].remove();
            } else {
              posts[posts.length - 1].remove();
            }
          }
        })
        .finally(() => {
          loading = false;
          loadingIndicator.classList.add('hidden');
        });
    }

    window.addEventListener('scroll', () => {
      const currentScrollY = window.scrollY;
      const scrollingDown = currentScrollY > lastScrollY;
      const scrollingUp = currentScrollY < lastScrollY;
      
      // Calculate distances from top and bottom
      const distanceFromTop = currentScrollY;
      const distanceFromBottom = document.documentElement.scrollHeight - (currentScrollY + window.innerHeight);
      
      // Load next post when scrolling down near bottom
      if (scrollingDown && distanceFromBottom < 200 && hasNext) {
        loadPost(currentPostId, 'next');
      }
      
      // Load previous post when scrolling up near top
      if (scrollingUp && distanceFromTop < 200 && hasPrevious) {
        loadPost(currentPostId, 'previous');
      }
      
      lastScrollY = currentScrollY;
    });
  });
<% end %>
